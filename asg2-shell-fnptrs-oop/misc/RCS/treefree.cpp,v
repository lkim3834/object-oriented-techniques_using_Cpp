head	1.89;
access;
symbols;
locks;
comment	@// @;


1.89
date	2020.11.05.03.27.34;	author -;	state -;
branches;
next	1.88;

1.88
date	2020.11.05.03.24.07;	author -;	state -;
branches;
next	1.87;

1.87
date	2020.11.05.03.12.49;	author -;	state -;
branches;
next	1.86;

1.86
date	2020.11.05.02.59.29;	author -;	state -;
branches;
next	1.85;

1.85
date	2020.11.05.02.59.02;	author -;	state -;
branches;
next	1.84;

1.84
date	2020.11.05.02.56.41;	author -;	state -;
branches;
next	1.83;

1.83
date	2020.11.05.02.55.49;	author -;	state -;
branches;
next	1.82;

1.82
date	2020.11.05.02.51.02;	author -;	state -;
branches;
next	1.81;

1.81
date	2020.11.05.02.50.43;	author -;	state -;
branches;
next	1.80;

1.80
date	2020.11.05.02.39.07;	author -;	state -;
branches;
next	1.79;

1.79
date	2020.11.05.00.25.00;	author -;	state -;
branches;
next	1.78;

1.78
date	2020.11.05.00.24.36;	author -;	state -;
branches;
next	1.77;

1.77
date	2020.11.05.00.23.59;	author -;	state -;
branches;
next	1.76;

1.76
date	2020.11.05.00.23.18;	author -;	state -;
branches;
next	1.75;

1.75
date	2019.04.22.22.56.04;	author -;	state -;
branches;
next	1.74;

1.74
date	2019.04.22.22.55.39;	author -;	state -;
branches;
next	1.73;

1.73
date	2019.04.22.22.54.53;	author -;	state -;
branches;
next	1.72;

1.72
date	2015.06.29.20.45.29;	author -;	state -;
branches;
next	1.71;

1.71
date	2015.03.27.05.15.48;	author -;	state -;
branches;
next	1.70;

1.70
date	2015.03.27.05.13.47;	author -;	state -;
branches;
next	1.69;

1.69
date	2015.03.27.05.13.19;	author -;	state -;
branches;
next	1.68;

1.68
date	2015.03.27.05.12.16;	author -;	state -;
branches;
next	1.67;

1.67
date	2015.03.27.05.03.28;	author -;	state -;
branches;
next	1.66;

1.66
date	2015.03.27.05.02.11;	author -;	state -;
branches;
next	1.65;

1.65
date	2015.03.27.05.00.53;	author -;	state -;
branches;
next	1.64;

1.64
date	2015.03.27.05.00.42;	author -;	state -;
branches;
next	1.63;

1.63
date	2015.03.27.05.00.07;	author -;	state -;
branches;
next	1.62;

1.62
date	2015.03.27.04.59.48;	author -;	state -;
branches;
next	1.61;

1.61
date	2015.03.27.04.59.09;	author -;	state -;
branches;
next	1.60;

1.60
date	2015.03.27.04.56.26;	author -;	state -;
branches;
next	1.59;

1.59
date	2015.03.27.04.54.50;	author -;	state -;
branches;
next	1.58;

1.58
date	2015.03.27.04.54.02;	author -;	state -;
branches;
next	1.57;

1.57
date	2015.03.27.04.53.51;	author -;	state -;
branches;
next	1.56;

1.56
date	2015.03.27.04.51.28;	author -;	state -;
branches;
next	1.55;

1.55
date	2015.03.27.04.51.16;	author -;	state -;
branches;
next	1.54;

1.54
date	2015.03.27.04.49.52;	author -;	state -;
branches;
next	1.53;

1.53
date	2015.03.27.04.49.19;	author -;	state -;
branches;
next	1.52;

1.52
date	2015.03.27.04.47.11;	author -;	state -;
branches;
next	1.51;

1.51
date	2015.03.27.04.46.40;	author -;	state -;
branches;
next	1.50;

1.50
date	2015.03.27.04.45.13;	author -;	state -;
branches;
next	1.49;

1.49
date	2015.03.27.04.42.20;	author -;	state -;
branches;
next	1.48;

1.48
date	2015.03.27.04.42.00;	author -;	state -;
branches;
next	1.47;

1.47
date	2015.03.27.04.41.25;	author -;	state -;
branches;
next	1.46;

1.46
date	2015.03.27.04.40.56;	author -;	state -;
branches;
next	1.45;

1.45
date	2015.03.27.04.38.46;	author -;	state -;
branches;
next	1.44;

1.44
date	2015.03.27.04.38.18;	author -;	state -;
branches;
next	1.43;

1.43
date	2015.03.27.04.37.47;	author -;	state -;
branches;
next	1.42;

1.42
date	2015.03.27.04.34.32;	author -;	state -;
branches;
next	1.41;

1.41
date	2015.03.27.04.34.18;	author -;	state -;
branches;
next	1.40;

1.40
date	2015.03.27.04.33.44;	author -;	state -;
branches;
next	1.39;

1.39
date	2015.03.27.04.32.06;	author -;	state -;
branches;
next	1.38;

1.38
date	2015.03.27.04.29.51;	author -;	state -;
branches;
next	1.37;

1.37
date	2015.03.27.04.28.01;	author -;	state -;
branches;
next	1.36;

1.36
date	2015.03.27.04.26.43;	author -;	state -;
branches;
next	1.35;

1.35
date	2015.03.27.04.26.27;	author -;	state -;
branches;
next	1.34;

1.34
date	2015.03.27.04.25.11;	author -;	state -;
branches;
next	1.33;

1.33
date	2015.03.27.04.24.41;	author -;	state -;
branches;
next	1.32;

1.32
date	2015.03.27.04.24.25;	author -;	state -;
branches;
next	1.31;

1.31
date	2015.03.27.04.19.47;	author -;	state -;
branches;
next	1.30;

1.30
date	2015.03.27.04.17.03;	author -;	state -;
branches;
next	1.29;

1.29
date	2015.03.27.04.16.24;	author -;	state -;
branches;
next	1.28;

1.28
date	2015.03.27.04.15.50;	author -;	state -;
branches;
next	1.27;

1.27
date	2015.03.27.04.15.26;	author -;	state -;
branches;
next	1.26;

1.26
date	2015.03.27.04.14.53;	author -;	state -;
branches;
next	1.25;

1.25
date	2015.03.27.04.14.17;	author -;	state -;
branches;
next	1.24;

1.24
date	2015.03.27.04.13.57;	author -;	state -;
branches;
next	1.23;

1.23
date	2015.03.27.04.13.09;	author -;	state -;
branches;
next	1.22;

1.22
date	2015.03.27.04.12.43;	author -;	state -;
branches;
next	1.21;

1.21
date	2015.03.27.04.05.49;	author -;	state -;
branches;
next	1.20;

1.20
date	2015.03.27.04.05.29;	author -;	state -;
branches;
next	1.19;

1.19
date	2015.03.27.04.03.49;	author -;	state -;
branches;
next	1.18;

1.18
date	2015.03.27.04.03.22;	author -;	state -;
branches;
next	1.17;

1.17
date	2015.03.27.04.01.08;	author -;	state -;
branches;
next	1.16;

1.16
date	2015.03.27.04.00.55;	author -;	state -;
branches;
next	1.15;

1.15
date	2015.03.27.03.57.05;	author -;	state -;
branches;
next	1.14;

1.14
date	2015.03.27.03.56.38;	author -;	state -;
branches;
next	1.13;

1.13
date	2015.03.27.03.55.30;	author -;	state -;
branches;
next	1.12;

1.12
date	2015.03.27.03.55.13;	author -;	state -;
branches;
next	1.11;

1.11
date	2015.03.27.03.53.45;	author -;	state -;
branches;
next	1.10;

1.10
date	2015.03.27.03.51.25;	author -;	state -;
branches;
next	1.9;

1.9
date	2015.03.27.03.50.51;	author -;	state -;
branches;
next	1.8;

1.8
date	2015.03.27.03.50.43;	author -;	state -;
branches;
next	1.7;

1.7
date	2015.03.27.03.49.58;	author -;	state -;
branches;
next	1.6;

1.6
date	2015.03.27.03.46.43;	author -;	state -;
branches;
next	1.5;

1.5
date	2015.03.27.03.45.01;	author -;	state -;
branches;
next	1.4;

1.4
date	2015.03.27.03.44.20;	author -;	state -;
branches;
next	1.3;

1.3
date	2015.03.27.03.40.44;	author -;	state -;
branches;
next	1.2;

1.2
date	2015.03.27.03.39.34;	author -;	state -;
branches;
next	1.1;

1.1
date	2015.03.27.03.38.53;	author -;	state -;
branches;
next	;


desc
@@


1.89
log
@-
@
text
@// $Id: treefree.cpp,v 1.86 2020-11-04 18:59:29-08 - - $

// Shared_ptrs use reference counting in order to automatically
// free objects, but that does not work for cyclic data structures.
// This illustrates how to avoid the problem.

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
using namespace std;

/////////////////////////////////////////////////////////////////
// tree.h
/////////////////////////////////////////////////////////////////

class tree;
using tree_ptr = shared_ptr<tree>;
using tree_dir = map<string,tree_ptr>;
using tree_itor = tree_dir::iterator;

class tree {
      friend ostream& operator<< (ostream&, const tree*);
   private:
      static size_t next_seq;
      size_t seq;
      tree_dir data;
      void print (size_t);
      void disown (size_t);
   public:
      static const string PARENT;
      static tree_ptr make_root();
      static tree_ptr make (tree_ptr ptr);
      explicit tree (tree_ptr parent);
      ~tree();
      void emplace (const tree_dir::key_type&,
                    const tree_dir::mapped_type&);
      const tree_itor begin() { return data.begin(); }
      const tree_itor end() { return data.end(); }
      void print() { print (0); }
      void disown() { disown (0); }
};

/////////////////////////////////////////////////////////////////
// tree.cpp
/////////////////////////////////////////////////////////////////

size_t tree::next_seq {0};
const string tree::PARENT = "..";


ostream& operator<< (ostream& out, const tree* ptr) {
   if (ptr == nullptr) return out << "nullptr";
                  else return out << "[" << ptr->seq << "]"
                           << static_cast<const void*> (ptr);
}

tree::tree (tree_ptr parent): seq(next_seq++), data({{PARENT,parent}}) {
   cout << this << "->" << __PRETTY_FUNCTION__
        << ": parent=" << parent << endl;
}

tree::~tree() {
   cout << this << "->" << __PRETTY_FUNCTION__ << ":";
   for (const auto& pair: data) cout << " " << pair.first;
   cout << endl;
}

void tree::emplace (const tree_dir::key_type& key,
                    const tree_dir::mapped_type& value) {
   data.emplace (key, value);
}

void tree::disown (size_t depth) {
   cout << __PRETTY_FUNCTION__ << ": "
        << setw (depth * 3) << "" << this << endl;
   data.erase (PARENT);
   for (auto pair: data) pair.second->disown (depth + 1);
}

// Depth-first pre-order traversal.
void tree::print (size_t depth) {
   for (const auto itor: data) {
      cout << __PRETTY_FUNCTION__ << ": "
           << setw (depth * 3) << "" << this
           << ": \"" << itor.first << "\" -> " << itor.second
           << " (" << itor.second.use_count() << ")" << endl;
      if (itor.first != PARENT and itor.second != nullptr) {
         itor.second->print (depth + 1);
      }
   }
}

tree_ptr tree::make_root() {
   tree_ptr ptr = make_shared<tree> (nullptr);
   ptr->data[PARENT] = ptr;
   return ptr;
}

tree_ptr tree::make (tree_ptr parent) {
   if (parent == nullptr) throw logic_error ("tree::make(nullptr)");
   return make_shared<tree> (parent);
}


/////////////////////////////////////////////////////////////////
// main.cpp
/////////////////////////////////////////////////////////////////

int main (int argc, char** argv) {
   cout << "Command:";
   for_each (&argv[0], &argv[argc], [](char* arg){cout << " " << arg;});
   cout << endl;

   bool want_disown = argc > 1 and argv[1] == string ("-d");
   shared_ptr<tree> root = tree::make_root();
   root->emplace ("foo", tree::make (root));
   root->emplace ("bar", tree::make (root));
   for (auto itor: *root) {
      if (itor.first == tree::PARENT) continue;
      for (int count = 0; count < 3; ++count) {
         string quux = "qux";
         quux.insert (1, count, 'u');
         itor.second->emplace (quux, tree::make (itor.second));
      }
   }
   cout << "[seq]address: key -> value (use count)" << endl;
   root->print();
   if (want_disown) root->disown();
   return 0;
}

//TEST// valgrind treefree -0 >treefree.out-0 2>&1
//TEST// valgrind treefree -d >treefree.out-d 2>&1
//TEST// mkpspdf treefree.ps treefree.cpp* treefree.out*

@


1.88
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.87 2020-11-04 19:12:49-08 - - $
d24 1
a24 1
      friend ostream& operator<< (ostream&, const tree_ptr);
d53 1
a53 1
ostream& operator<< (ostream& out, const tree_ptr ptr) {
d56 1
a56 1
                          << ptr.get() << "(" << ptr.use_count() << ")";
d86 3
a88 2
           << setw (depth * 3) << "" << this << ": \""
           << itor.first << "\" -> " << itor.second << endl;
@


1.87
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.86 2020-11-04 18:59:29-08 - - $
d56 1
a56 1
                           << ptr.get();
d86 2
a87 3
           << setw (depth * 3) << "" << this
           << ": \"" << itor.first << "\" -> " << itor.second
           << " (" << itor.second.use_count() << ")" << endl;
@


1.86
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.82 2020-11-04 18:51:02-08 - - $
d24 1
a24 1
      friend ostream& operator<< (ostream&, const tree*);
d53 1
a53 1
ostream& operator<< (ostream& out, const tree* ptr) {
d56 1
a56 1
                           << static_cast<const void*> (ptr);
@


1.85
log
@-
@
text
@d24 1
a24 1
      friend ostream& operator<< (ostream&, const tree_ptr);
d53 1
a53 1
ostream& operator<< (ostream& out, const tree_ptr ptr) {
@


1.84
log
@-
@
text
@d56 1
a56 1
                           << ptr;
@


1.83
log
@-
@
text
@d56 1
a56 1
                           << static_cast<const void*> (ptr);
@


1.82
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.81 2020-11-04 18:50:43-08 - - $
d24 1
a24 1
      friend ostream& operator<< (ostream&, const tree*);
d53 1
a53 1
ostream& operator<< (ostream& out, const tree* ptr) {
@


1.81
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.80 2020-11-04 18:39:07-08 - - $
d66 1
a66 1
   for (const auto& pair: data) cout << " " << data.first;
@


1.80
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.79 2020-11-04 16:25:00-08 - - $
d61 1
a61 1
        << ": " << parent << endl;
d65 3
a67 1
   cout << this << "->" << __PRETTY_FUNCTION__ << "()" << endl;
d79 1
a79 1
   for (auto n: data) n.second->disown (depth + 1);
d136 1
a136 1
//TEST// mkpspdf treefree.ps treefree.cpp* treefree.out-0
@


1.79
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.78 2020-11-04 16:24:36-08 - - $
d61 1
a61 1
        << "(" << parent << ")" << endl;
@


1.78
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.77 2020-11-04 16:23:59-08 - - $
d7 1
@


1.77
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.76 2020-11-04 16:23:18-08 - - $
d113 1
a113 1
   bool want_disown = argc > 1 and argv[1] == "-d";
@


1.76
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.75 2019-04-22 15:56:04-07 - - $
d127 1
a127 1
   root->disown();
@


1.75
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.74 2019-04-22 15:55:39-07 - - $
d109 5
a113 2
   (void) argc;
   (void) argv;
d131 3
a133 3
//TEST// alias grind='valgrind --leak-check=full --show-reachable=yes'
//TEST// grind treefree >treefree.out 2>treefree.ground
//TEST// mkpspdf treefree.ps treefree.cpp* treefree.out treefree.ground
@


1.74
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.73 2019-04-22 15:54:53-07 - - $
d51 1
a57 1

@


1.73
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.72 2015-06-29 13:45:29-07 - - $
a43 1

d57 1
@


1.72
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.71 2015-03-26 22:15:48-07 - - $
d59 2
a60 1
   cout << this << "->" << __func__ << "(" << parent << ")" << endl;
d64 1
a64 1
   cout << this << "->" << __func__ << "()" << endl;
d73 2
a74 1
   cout << __func__ << ": " << setw (depth * 3) << "" << this << endl;
d82 2
a83 1
      cout << __func__ << ": " << setw (depth * 3) << "" << this
@


1.71
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.70 2015-03-26 22:13:47-07 - - $
d34 1
a34 1
      tree (tree_ptr parent);
@


1.70
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.69 2015-03-26 22:13:19-07 - - $
d72 1
a72 2
   cout << setw (depth * 3) << "" << this << "->"
        << __func__ << "()" << endl;
d80 1
a80 1
      cout << setw (depth * 3) << "" << this
@


1.69
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.68 2015-03-26 22:12:16-07 - - $
d74 1
a75 1
   data.erase (PARENT);
@


1.68
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.67 2015-03-26 22:03:28-07 - - $
d74 1
a75 1
   for (auto n: data) n.second->disown (depth + 1);
@


1.67
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.66 2015-03-26 22:02:11-07 - - $
d127 2
a128 2
//TEST// grind treefree >treefree.out 2>&1
//TEST// mkpspdf treefree.ps treefree.cpp* treefree.out
@


1.66
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.65 2015-03-26 22:00:53-07 - - $
d128 1
a128 1
//TEST// mkpspdf treefree.ps treefree.cpp treefree.out
@


1.65
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.64 2015-03-26 22:00:42-07 - - $
d59 1
@


1.64
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.63 2015-03-26 22:00:07-07 - - $
d126 1
a126 1
//TEST// grind treefree >treefree.out
@


1.63
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.62 2015-03-26 21:59:48-07 - - $
d125 1
a125 1
//TEST// export grind='valgrind --leak-check=full --show-reachable=yes'
@


1.62
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.61 2015-03-26 21:59:09-07 - - $
d125 1
a125 1
//TEST// grind='valgrind --leak-check=full --show-reachable=yes'
a128 1

@


1.61
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.60 2015-03-26 21:56:26-07 - - $
d53 2
a54 2
   if (ptr == nullptr) out << "nullptr";
                  else out << "[" << ptr->seq << "]"
a55 1
   return out;
@


1.60
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.59 2015-03-26 21:54:50-07 - - $
a20 1
using void_cast = static_cast<const void*>;
d53 4
a56 1
   return out << "[" << ptr->seq << "]" << static_cast<const void*> (ptr);
d82 2
a83 4
           << ": \"" << itor.first << "\" -> ";
      if (itor.second == nullptr) cout << "nullptr";
                             else cout << itor.second;
      cout << " (" << itor.second.use_count() << ")" << endl;
@


1.59
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.58 2015-03-26 21:54:02-07 - - $
d21 1
d54 1
a54 2
   return out << "[" << ptr->seq << "]"
              << static_cast<const void*> (ptr);
d98 1
a98 2
   tree_ptr ptr = make_shared<tree> (parent);
   return ptr;
@


1.58
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.57 2015-03-26 21:53:51-07 - - $
a6 1
#include <assert>
d97 1
a97 1
   assert (parent != nullptr);
@


1.57
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.56 2015-03-26 21:51:28-07 - - $
d7 1
@


1.56
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.55 2015-03-26 21:51:16-07 - - $
d32 1
d90 6
d97 1
a98 1
   if (parent == nullptr) ptr->data[PARENT] = ptr;
d110 1
a110 1
   shared_ptr<tree> root = tree::make ();
@


1.55
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.54 2015-03-26 21:49:52-07 - - $
a29 1
      tree (tree_ptr parent);
d33 1
@


1.54
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.53 2015-03-26 21:49:19-07 - - $
d30 1
d33 1
a33 2
      static tree_ptr make (tree_ptr ptr = nullptr);
      tree (tree_ptr parent);
@


1.53
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.52 2015-03-26 21:47:11-07 - - $
d95 1
@


1.52
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.51 2015-03-26 21:46:40-07 - - $
d43 1
d119 5
@


1.51
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.50 2015-03-26 21:45:13-07 - - $
d71 1
a71 1
   for (auto n: data) n.second->disown();
@


1.50
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.49 2015-03-26 21:42:20-07 - - $
d32 1
a34 1
      void disown();
d40 1
a40 1
      static tree_ptr make (tree_ptr ptr = nullptr);
@


1.49
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.48 2015-03-26 21:42:00-07 - - $
d23 1
a23 1
      friend ostream& operator<< (ostream&, const tree* const);
d29 1
d50 3
a52 2
ostream& operator<< (ostream& out, const tree* const ptr) {
   return out << "[" << ptr->seq << "]" << static_cast<const void*> (ptr);
d67 3
a69 2
void tree::disown () {
   cout << this << "->" << __func__ << "()" << endl;
@


1.48
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.47 2015-03-26 21:41:25-07 - - $
d50 1
a50 1
   return out << "[" << ptr->seq << "]" << static_cast<void*> (ptr);
@


1.47
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.46 2015-03-26 21:40:56-07 - - $
d50 1
a50 1
   return out << "[" << ptr->seq << "]" << ptr;
@


1.46
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.45 2015-03-26 21:38:46-07 - - $
d23 1
a23 1
      friend ostream& operator<< (ostream&, tree_ptr);
@


1.45
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.44 2015-03-26 21:38:18-07 - - $
d49 2
a50 2
ostream& operator<< (ostream& out, tree_ptr ptr) {
   return out << "[" << ptr->seq << "]" << &*ptr;
d77 1
a77 1
            else cout << itor.second;
@


1.44
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.43 2015-03-26 21:37:47-07 - - $
d50 1
a50 1
   return out << "[" << ptr->seq << "]" << static_cast<void*> (ptr);
@


1.43
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.42 2015-03-26 21:34:32-07 - - $
d50 1
a50 1
   return out << "[" << ptr->seq << "]" << ptr;
@


1.42
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.41 2015-03-26 21:34:18-07 - - $
d23 1
d49 4
d74 2
a75 2
      cout << setw (depth * 3) << "" << "[" << seq << "]"
           << this << ": \"" << itor.first << "\" -> ";
d77 1
a77 1
            else cout << "[" << itor.second->seq << "]" << itor.second;
d86 3
a88 3
   tree_ptr node = make_shared<tree> (parent);
   if (parent == nullptr) node->data[PARENT] = node;
   return node;
@


1.41
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.40 2015-03-26 21:33:44-07 - - $
a27 1
      void disown();
d32 1
a52 1
   this->disown();
@


1.40
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.39 2015-03-26 21:32:06-07 - - $
d107 1
a107 1
   root = nullptr;
@


1.39
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.38 2015-03-26 21:29:51-07 - - $
d107 1
@


1.38
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.37 2015-03-26 21:28:01-07 - - $
d105 1
@


1.37
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.36 2015-03-26 21:26:43-07 - - $
d74 1
a74 1
      cout << endl;
@


1.36
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.35 2015-03-26 21:26:27-07 - - $
d52 1
@


1.35
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.34 2015-03-26 21:25:11-07 - - $
d61 1
a61 1
   cout << this << "->" << __func__ << () << endl;
@


1.34
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.33 2015-03-26 21:24:41-07 - - $
d61 1
@


1.33
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.32 2015-03-26 21:24:25-07 - - $
d62 1
a62 1
   for (auto n: node) n.second->disown();
@


1.32
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.31 2015-03-26 21:19:47-07 - - $
d28 1
a28 1
      void disown (tree_ptr node);
@


1.31
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.30 2015-03-26 21:17:03-07 - - $
d28 1
d52 1
a52 1
   data.clear();
d60 5
@


1.30
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.29 2015-03-26 21:16:24-07 - - $
d51 1
a51 1
   data.erase (PARENT);
@


1.29
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.28 2015-03-26 21:15:50-07 - - $
d90 1
a90 1
      if (itor.second == nullptr) continue;
@


1.28
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.27 2015-03-26 21:15:26-07 - - $
d37 1
a37 1
      static tree_ptr make_tree (tree_ptr ptr = nullptr);
d73 1
a73 1
tree_ptr tree::make_tree (tree_ptr parent) {
d86 3
a88 3
   shared_ptr<tree> root = make_tree ();
   root->emplace ("foo", make_tree (root));
   root->emplace ("bar", make_tree (root));
d94 1
a94 1
         itor.second->emplace (quux, make_tree (itor.second));
@


1.27
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.26 2015-03-26 21:14:53-07 - - $
d75 1
a75 1
   if (parent == nullptr) (*node)[PARENT] = node;
@


1.26
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.25 2015-03-26 21:14:17-07 - - $
d75 1
a75 1
   if (parent == nullptr) node[PARENT] = node;
@


1.25
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.24 2015-03-26 21:13:57-07 - - $
d73 1
a73 1
tree_ptr make_tree (tree_ptr parent) {
@


1.24
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.23 2015-03-26 21:13:09-07 - - $
a49 4
tree::tree(): seq(next_seq++) {
   data.emplace (PARENT, tree_ptr(this));
}

@


1.23
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.22 2015-03-26 21:12:43-07 - - $
d90 3
a92 3
   shared_ptr<tree> root = make_shared<tree> ();
   root->emplace ("foo", make_shared<tree> (root));
   root->emplace ("bar", make_shared<tree> (root));
d98 1
a98 1
         itor.second->emplace (quux, make_shared<tree> (itor.second));
@


1.22
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.21 2015-03-26 21:05:49-07 - - $
d80 1
@


1.21
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.20 2015-03-26 21:05:29-07 - - $
d29 1
a29 1
      tree();
d37 1
a39 2
const string PARENT = "..";

d45 1
d77 5
d89 1
a89 1
   shared_ptr<tree> root = make_shared<tree>();
@


1.20
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.19 2015-03-26 21:03:49-07 - - $
d51 1
a51 1
   data.emplace (PARENT, shared_ptr(this));
@


1.19
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.18 2015-03-26 21:03:22-07 - - $
d50 2
a51 1
tree::tree(): seq(next_seq++), data({{PARENT,shared_ptr(this)}}) {
@


1.18
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.17 2015-03-26 21:01:08-07 - - $
d50 1
a50 1
tree::tree(): seq(next_seq++), data({{PARENT,this}}) {
@


1.17
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.16 2015-03-26 21:00:55-07 - - $
d29 1
d50 3
d83 1
a83 1
   shared_ptr<tree> root = make_shared<tree> (nullptr);
@


1.16
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.15 2015-03-26 20:57:05-07 - - $
d86 1
a86 1
         quux.insert (1, count, "u");
@


1.15
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.14 2015-03-26 20:56:38-07 - - $
d80 2
a81 3
   for (string key = "a"; key <= "c"; ++key[0]) {
      root->emplace (key, make_shared<tree> (root));
   }
d84 4
a87 3
      for (int i = 1; i <= 3; ++i) {
         itor.second->emplace (to_string (i),
                               make_shared<tree> (itor.second));
@


1.14
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.13 2015-03-26 20:55:30-07 - - $
d80 1
a80 1
   for (auto key = "a"; key <= "c"; ++key[0]) {
@


1.13
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.12 2015-03-26 20:55:13-07 - - $
d80 2
a81 2
   for (char ch = 'a'; ch <= 'c'; ++ch) {
      root->emplace (string (ch), make_shared<tree> (root));
@


1.12
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.11 2015-03-26 20:53:45-07 - - $
d81 1
a81 1
      root->emplace (ch, make_shared<tree> (root));
@


1.11
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.10 2015-03-26 20:51:25-07 - - $
d80 3
a82 2
   root->emplace ("a", make_shared<tree> (root));
   root->emplace ("b", make_shared<tree> (root));
@


1.10
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.9 2015-03-26 20:50:51-07 - - $
d84 4
a87 3
      itor.second->emplace ("1", make_shared<tree> (itor.second));
      itor.second->emplace ("2", make_shared<tree> (itor.second));
      itor.second->emplace ("null", nullptr);
@


1.9
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.8 2015-03-26 20:50:43-07 - - $
d61 2
a62 2
      cout << setw (depth * 3) << "[" << seq << "]" << this << ": \""
            << itor.first << "\" -> ";
@


1.8
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.7 2015-03-26 20:49:58-07 - - $
a57 3
ostream& tree::indent (size_t depth) {
}

@


1.7
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.6 2015-03-26 20:46:43-07 - - $
a34 1
      ostream& indent (size_t);
a58 1
   return cout << setw (depth * 3) << "";
d64 1
a64 1
      indent (depth) "[" << seq << "]" << this << ": \""
@


1.6
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.5 2015-03-26 20:45:01-07 - - $
d63 1
d66 2
a67 2
      indent (depth) << this << "(" << seq << "): \""
                     << itor.first << "\" -> ";
d69 1
a69 1
                             else cout << itor.second;
@


1.5
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.4 2015-03-26 20:44:20-07 - - $
d65 2
a66 1
      indent (depth) << this << ": " << itor.first << " -> ";
@


1.4
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.3 2015-03-26 20:40:44-07 - - $
d65 1
a65 1
      indent (depth) << &*itor << ": " << itor.first << " -> ";
@


1.3
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.2 2015-03-26 20:39:34-07 - - $
d35 1
d59 4
d65 1
a65 1
      cout << setw (depth * 3) << "" << itor.first << " -> ";
a90 1
   cout << "root = " << root << endl;
@


1.2
log
@-
@
text
@d1 1
a1 1
// $Id: treefree.cpp,v 1.1 2015-03-26 20:38:53-07 - - $
d38 1
a38 1
constexpr string PARENT {".."};
@


1.1
log
@-
@
text
@d1 1
a1 1
// $Id: freetree.cpp,v 1.29 2015-03-26 18:48:08-07 - - $
d38 1
a38 1
constexpr string PARENT = "..";
@
